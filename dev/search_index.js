var documenterSearchIndex = {"docs":
[{"location":"#L2ODLL.jl","page":"Home","title":"L2ODLL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is a work in progress. Please open an issue if content is missing / erroneous.","category":"page"},{"location":"","page":"Home","title":"Home","text":"L2ODLL.jl implements the Dual Lagrangian Learning (DLL) method of Tanneau and Hentenryck (2024) using JuMP.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(; url=\"https://github.com/LearningToOptimize/L2ODLL.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package simplifies the implementation of DLL by taking as input a primal JuMP model, then automatically generating the dual projection and completion functions which can be used in the training and inference of DLL models. The basic usage is as follows:","category":"page"},{"location":"#Define-your-(primal)-model-using-JuMP","page":"Home","title":"Define your (primal) model using JuMP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the purposes of this example, we'll use a portfolio optimization problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JuMP, LinearAlgebra\n\nmodel = Model()\n\n# define constant problem data\nΣ = [166 34 58; 34 64 4; 58 4 100] / 100^2\nN = size(Σ, 1)\n\n# define variables\n@variable(model, x[1:N])\nset_lower_bound.(x, 0)  # we explicitly set upper and lower bounds\nset_upper_bound.(x, 1)  #   in order to use the BoundDecomposition\n\n# define parameteric problem data\nμ0 = randn(N)\nγ0 = rand()\n@variable(model, μ[1:N] in MOI.Parameter.(μ0))\n@variable(model, γ in MOI.Parameter(γ0))\n\n# define constraints\n@constraint(model, simplex, sum(x) == 1)\n@constraint(model, risk, [γ; cholesky(Σ).L * x] in SecondOrderCone())\n\n# define objective\n@objective(model, Max, dot(μ,x))","category":"page"},{"location":"#Decompose-and-build-the-functions","page":"Home","title":"Decompose and build the functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since all the variables have finite bounds, L2ODLL will automatically pick the BoundDecomposition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using L2ODLL\n\nL2ODLL.decompose!(model)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, L2ODLL has automatically generated the dual projection and completion layer. To compute the dual objective value and gradient with respect to the prediction, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"param_value = ... # some values for μ and γ\ny_predicted = nn(param_value) # e.g. neural network inference\n\ndobj = L2ODLL.dual_objective(model, y_predicted, param_value)\ndobj_wrt_y = L2ODLL.dual_objective_gradient(model, y_predicted, param_value)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This also works with batches, using broadcasting:","category":"page"},{"location":"","page":"Home","title":"Home","text":"dobj = L2ODLL.dual_objective.(model, y_predicted_batch, param_value_batch)\ndobj_wrt_y = L2ODLL.dual_objective_gradient.(model, y_predicted_batch, param_value_batch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThese functions currently run on the CPU. A batched GPU-friendly version is coming soon.","category":"page"},{"location":"#Math-Background","page":"Home","title":"Math Background","text":"","category":"section"},{"location":"#Decomposition","page":"Home","title":"Decomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In DLL, the primal constraints (dual variables) are decomposed into a predicted set and a completed set. Consider the primal-dual pair:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  c^top x\n\n textst  Ax + b in mathcalC\n\n  x in mathbbR^n\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_y  - b^top y\n\n textst  A^top y = c\n\n  y in mathcalC^*\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"After the decomposition, we have:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  c^top x\n\n textst  Ax + b in mathcalC\n\n phantomtextst  Hx + h in mathcalK\n\n  x in mathbbR^n\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_y  - b^top y\n\n textst  A^top y + H^top z = c\n\n  y in mathcalC^* z in mathcalK^*\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the completion model is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n maxnolimits_z  - h^top z - b^top y\n\n textst  H z = c - A^top y\n\n  z in mathcalK^*\nendaligned\nquadquadquadquad\nbeginaligned\n minnolimits_x  (c-A^top y)^top x\n\n phantomtextst  Hx + h in mathcalK\n\n  x in mathbbR^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"To train the neural network, we need the gradient of the optimal value with respect to the predicted y. This is nabla_y = -b-Ax where x is the optimal dual solution corresponding to the affine constraints in the completion model. In the special cases below, we specify just the expression for x in this formula.","category":"page"},{"location":"#Bounded-Decomposition","page":"Home","title":"Bounded Decomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When all primal variables have finite upper and lower bounds, a natural way to decompose the constraints is to have z correspond to the bound constraints, and y correspond to the main constraints, i.e.","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  c^top x\n\n textst  Ax + b in mathcalC\n\n  l leq x leq u\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_yz_lz_u  - b^top y - l^top z_l - u^top z_u\n\n textst  A^top y + z_l + z_u = c\n\n  y in mathcalC^* z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the completion model is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n maxnolimits_z_lz_u  - l^top z_l - u^top z_u - b^top y\n\n textst  z_l + z_u = c - A^top y\n\n  z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nquadquadquadquad\nbeginaligned\n minnolimits_x  (c-A^top y)^top x\n\n  l leq x leq u\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model admits a closed form solution, z_l = c-A^top y^+ and z_u = -c-A^top y^-. Furthermore, the x that defines the (sub-)gradient is given element-wise by l if c-A^top y  0, u if c-A^top y  0, and xinlu otherwise.","category":"page"},{"location":"#(Strictly)-Convex-QP","page":"Home","title":"(Strictly) Convex QP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the convex QP case, the primal has a strictly convex quadratic objective function, i.e. Qsucc 0. In that case it is natural to use the main constraints as the predicted set and to complete the quadratic slack dual variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  x^top Q x + c^top x\n\n textst  Ax + b in mathcalC\n\n  x in mathbbR^n\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_y  - b^top y - z^top Q z\n\n textst  A^top y + Qz = c\n\n  y in mathcalC^* z in mathbbR^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the completion model is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n maxnolimits_z  - z^top Q z - b^top y\n\n textst  Q z = c - A^top y\n\n  z in mathbbR^n\nendaligned\nquadquadquadquad\nbeginaligned\n minnolimits_x  x^top Q x + (c-A^top y)^top x\n\n  x in mathbbR^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model admits a closed form solution, z = Q^-1(c - A^top y). Furthermore, the closed form dual solution in this case is x=z.","category":"page"},{"location":"#Decomposition-detection","page":"Home","title":"Decomposition detection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThe decomposition detection is very basic, based on minimizing the number of predicted dual variables. In some cases, it may actually be preferred to to predict more dual variables, if they are for some reason easier to learn. In that case, users should manually specify the decomposition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"L2ODLL automatically detects the decomposition to use based on the model. The current detection logic is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"If all variables have finite upper and lower bounds, use the bounded decomposition.\nIf all variables have a quadratic objective term, use the convex QP decomposition.\nOtherwise, use the generic decomposition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The order of preference is to maximize the number of completed dual variables among the closed-form solutions, and if no closed-form solution is available, to use the generic decomposition. Thus, the bounded decomposition is preferred over the convex QP decomposition, as illustrated by the following example.","category":"page"},{"location":"#Bounded-with-quadratic-objective","page":"Home","title":"Bounded with quadratic objective","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the case where bounded decomposition is used with a model that has a quadratic objective, L2ODLL prefers the bounded decomposition, leading to the following models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  x^top Q x + c^top x\n\n textst  Ax + b in mathcalC\n\n  l leq x leq u\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_wyz_lz_u  - b^top y - w^top Q w - l^top z_l - u^top z_u\n\n textst  A^top y + Qw + z_l + z_u = c\n\n  y in mathcalC^* w in mathbbR^n z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the completion model is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n maxnolimits_z_lz_u  - l^top z_l - u^top z_u - b^top y - w^top Q w\n\n textst  z_l + z_u = c - A^top y - Qw   \n\n  z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nquadquadquadquad\nbeginaligned\n minnolimits_x  (c-A^top y - Qw)^top x\n\n  l leq x leq u\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model admits a closed form solution, z_l = c-A^top y-Qw^+ and z_u = -c-A^top y-Qw^-. Furthermore, the x that defines the (sub-)gradient is given element-wise by l if c-A^top y-Qw  0, u if c-A^top y-Qw  0, and xinlu otherwise. Note that the gradient of the objective with respect to w is nabla_w = -(Q+Q^top)w -Q^top x.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This completes 2n dual variables, leaving the neural network to predict m+n dual variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider the convex QP decomposition in this case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  x^top Q x + c^top x\n\n textst  Ax + b in mathcalC\n\n  l leq x leq u\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_wyz_lz_u  - b^top y - w^top Q w - l^top z_l - u^top z_u\n\n textst  A^top y + Qw + z_l + z_u = c\n\n  y in mathcalC^* w in mathbbR^n z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the completion model is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n maxnolimits_w  - w^top Q w - b^top y - l^top z_l - u^top z_u \n\n textst  Qw = c - A^top y - z_l - z_u   \n\n  w in mathbbR^n\nendaligned\nquadquadquadquad\nbeginaligned\n minnolimits_x  x^top Q x + (c-A^top y - z_l - z_u)^top x\n\n  x in mathbbR^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"This model admits a closed form solution, w = Q^-1(c - A^top y - z_l - z_u). Furthermore, the closed form dual solution in this case is x=w.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This completes n dual variables, leaving the neural network to predict m+2n dual variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Naturally, one may consider using both decompositions, i.e. to predict only the y variables and to recover w, z_l, and z_u. Let us consider this case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n minnolimits_x  x^top Q x + c^top x\n\n textst  Ax + b in mathcalC\n\n  l leq x leq u\nendaligned\nquadquadquadquad\nbeginaligned\n maxnolimits_wyz_lz_u  - b^top y - w^top Q w - l^top z_l - u^top z_u\n\n textst  A^top y + Qw + z_l + z_u = c\n\n  y in mathcalC^* w in mathbbR^n z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the completion model is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nbeginaligned\n maxnolimits_wz_lz_u  - w^top Q w - l^top z_l - u^top z_u - b^top y\n\n textst  Qw + z_l + z_u = c - A^top y\n\n  w in mathbbR^n z_l in mathbbR_+^n z_u in mathbbR_-^n\nendaligned\nquadquadquadquad\nbeginaligned\n minnolimits_x  x^top Q x + (c-A^top y)^top x\n\n  l leq x leq u\nendaligned\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is an n-dimensional box-constrained convex QP, for which there is no closed form solution. Note that by using a custom generic decomposition, L2ODLL can still be used to set up this problem and solve it using a JuMP-compatible QP solver.","category":"page"}]
}
